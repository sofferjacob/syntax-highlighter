<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Syntax Highlighter</title>
</head>
<body>
    <h1>Syntax Highlighter</h1>
    <h3>Jacobo Soffer Levy | A01028653</h3>
    <h4>Date 2022-05-23 01:52:04.135935</h3>
    <pre>
<span class="kw">package </span><span class="vr">endpoints
</span><span>
</span><span class="kw">import </span><span class="vr"><span class="op">(</span>
</span><span>	</span><span class="st">"bytes"</span><span>
</span><span>	</span><span class="st">"crypto/md5"</span><span>
</span><span>	</span><span class="st">"encoding/hex"</span><span>
</span><span>	</span><span class="st">"hash"</span><span>
</span><span>	</span><span class="st">"sort"</span><span>
</span><span>
</span><span>	</span><span class="st">"k8s.io/apimachinery/pkg/types"</span><span>
</span><span class="vr">	hashutil </span><span class="st">"k8s.io/kubernetes/pkg/util/hash"</span><span>
</span><span class="vr"><span class="op">)</span>
</span><span>
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">RepackSubsets </span><span class="vr">takes </span><span class="vr">a </span><span class="vr">slice </span><span class="vr">of </span><span class="vr">EndpointSubset </span><span class="vr">objects<span class="op">,</span> </span><span class="vr">expands </span><span class="vr">it </span><span class="vr">to </span><span class="vr">the </span><span class="vr">full
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">representation<span class="op">,</span> </span><span class="vr">and </span><span class="vr">then </span><span class="vr">repacks </span><span class="vr">that </span><span class="vr">into </span><span class="vr">the </span><span class="vr">canonical </span><span class="vr">layout<span class="op">.</span> </span><span> </span><span class="vr">This
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">ensures </span><span class="vr">that </span><span class="vr">code </span><span class="vr">which </span><span class="vr">operates </span><span class="vr">on </span><span class="vr">these </span><span class="vr">objects </span><span class="vr">can </span><span class="vr">rely </span><span class="vr">on </span><span class="vr">the </span><span class="vr">common
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">form </span><span class="kw">for </span><span class="vr">things </span><span class="vr">like </span><span class="vr">comparison<span class="op">.</span> </span><span> </span><span class="vr">The </span><span class="vr">result </span><span class="vr">is </span><span class="vr">a </span><span class="vr">newly </span><span class="vr">allocated </span><span class="vr">slice<span class="op">.</span>
</span><span class="kw">func </span><span class="vr">RepackSubsets<span class="op">(</span></span><span class="vr">subsets </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointSubset<span class="op">)</span> </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointSubset </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">First </span><span class="kw">map </span><span class="vr">each </span><span class="vr">unique </span><span class="vr">port </span><span class="vr">definition </span><span class="vr">to </span><span class="vr">the </span><span class="vr">sets </span><span class="vr">of </span><span class="vr">hosts </span><span class="vr">that
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">offer </span><span class="vr">it<span class="op">.</span>
</span><span class="vr">	allAddrs </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">map<span class="op">[</span></span><span class="vr">addressKey<span class="op">]</span></span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress<span class="op">{</span></span><span class="vr"><span class="op">}</span>
</span><span class="vr">	portToAddrReadyMap </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">map<span class="op">[</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointPort<span class="op">]</span></span><span class="vr">addressSet<span class="op">{</span></span><span class="vr"><span class="op">}</span>
</span><span class="kw">	for </span><span class="vr">i </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">subsets </span><span class="vr"><span class="op">{</span>
</span><span class="kw">		if </span><span class="vr">len<span class="op">(</span></span><span class="vr">subsets<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">.</span></span><span class="vr">Ports<span class="op">)</span> </span><span class="vr"><span class="op">=</span></span><span class="vr"><span class="op">=</span> </span><span class="nm">0 </span><span class="vr"><span class="op">{</span>
</span><span class="vr">			<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Don't </span><span class="vr">discard </span><span class="vr">endpoints </span><span class="vr">with </span><span class="vr">no </span><span class="vr">ports </span><span class="vr">defined<span class="op">,</span> </span><span class="vr">use </span><span class="vr">a </span><span class="vr">sentinel<span class="op">.</span>
</span><span class="vr">			mapAddressesByPort<span class="op">(</span></span><span class="vr"><span class="op">&</span></span><span class="vr">subsets<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointPort<span class="op">{</span></span><span class="vr">Port<span class="op">:</span> </span><span class="vr"><span class="op">-</span></span><span class="vr">1<span class="op">}</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">allAddrs<span class="op">,</span> </span><span class="vr">portToAddrReadyMap<span class="op">)</span>
</span><span class="vr">		<span class="op">}</span> </span><span class="kw">else </span><span class="vr"><span class="op">{</span>
</span><span class="kw">			for </span><span class="vr">_<span class="op">,</span> </span><span class="vr">port </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">subsets<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">.</span></span><span class="vr">Ports </span><span class="vr"><span class="op">{</span>
</span><span class="vr">				mapAddressesByPort<span class="op">(</span></span><span class="vr"><span class="op">&</span></span><span class="vr">subsets<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">port<span class="op">,</span> </span><span class="vr">allAddrs<span class="op">,</span> </span><span class="vr">portToAddrReadyMap<span class="op">)</span>
</span><span class="vr">			<span class="op">}</span>
</span><span class="vr">		<span class="op">}</span>
</span><span class="vr">	<span class="op">}</span>
</span><span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Next<span class="op">,</span> </span><span class="kw">map </span><span class="vr">the </span><span class="vr">sets </span><span class="vr">of </span><span class="vr">hosts </span><span class="vr">to </span><span class="vr">the </span><span class="vr">sets </span><span class="vr">of </span><span class="vr">ports </span><span class="vr">they </span><span class="vr">offer<span class="op">.</span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Go </span><span class="vr">does </span><span class="vr">not </span><span class="vr">allow </span><span class="vr">maps </span><span class="vr">or </span><span class="vr">slices </span><span class="vr">as </span><span class="vr">keys </span><span class="vr">to </span><span class="vr">maps<span class="op">,</span> </span><span class="vr">so </span><span class="vr">we </span><span class="vr">have
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">to </span><span class="vr">synthesize </span><span class="vr">an </span><span class="vr">artificial </span><span class="vr">key </span><span class="vr">and </span><span class="vr">do </span><span class="vr">a </span><span class="vr">sort </span><span class="vr">of </span><span class="vr">2<span class="op">-</span></span><span class="vr">part
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">associative </span><span class="vr">entity<span class="op">.</span>
</span><span class="kw">	type </span><span class="vr">keyString </span><span class="tp">string
</span><span class="vr">	keyToAddrReadyMap </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">map<span class="op">[</span></span><span class="vr">keyString<span class="op">]</span></span><span class="vr">addressSet<span class="op">{</span></span><span class="vr"><span class="op">}</span>
</span><span class="vr">	addrReadyMapKeyToPorts </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">map<span class="op">[</span></span><span class="vr">keyString<span class="op">]</span></span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointPort<span class="op">{</span></span><span class="vr"><span class="op">}</span>
</span><span class="kw">	for </span><span class="vr">port<span class="op">,</span> </span><span class="vr">addrs </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">portToAddrReadyMap </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		key </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">keyString<span class="op">(</span></span><span class="vr">hashAddresses<span class="op">(</span></span><span class="vr">addrs<span class="op">)</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">		keyToAddrReadyMap<span class="op">[</span></span><span class="vr">key<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">addrs
</span><span class="kw">		if </span><span class="vr">port<span class="op">.</span></span><span class="vr">Port </span><span class="vr"><span class="op">></span> </span><span class="nm">0 </span><span class="vr"><span class="op">{</span> </span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">avoid </span><span class="vr">sentinels
</span><span class="vr">			addrReadyMapKeyToPorts<span class="op">[</span></span><span class="vr">key<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">append<span class="op">(</span></span><span class="vr">addrReadyMapKeyToPorts<span class="op">[</span></span><span class="vr">key<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">port<span class="op">)</span>
</span><span class="vr">		<span class="op">}</span> </span><span class="kw">else </span><span class="vr"><span class="op">{</span>
</span><span class="kw">			if </span><span class="vr">_<span class="op">,</span> </span><span class="vr">found </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">addrReadyMapKeyToPorts<span class="op">[</span></span><span class="vr">key<span class="op">]</span></span><span class="vr"><span class="op">;</span> </span><span class="vr"><span class="op">!</span></span><span class="vr">found </span><span class="vr"><span class="op">{</span>
</span><span class="vr">				<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Force </span><span class="vr">it </span><span class="vr">to </span><span class="vr">be </span><span class="vr">present </span><span class="vr">in </span><span class="vr">the </span><span class="kw">map
</span><span class="vr">				addrReadyMapKeyToPorts<span class="op">[</span></span><span class="vr">key<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="tp">nil
</span><span class="vr">			<span class="op">}</span>
</span><span class="vr">		<span class="op">}</span>
</span><span class="vr">	<span class="op">}</span>
</span><span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Next<span class="op">,</span> </span><span class="vr">build </span><span class="vr">the </span><span class="vr">N<span class="op">-</span></span><span class="vr">to<span class="op">-</span></span><span class="vr">M </span><span class="vr">association </span><span class="vr">the </span><span class="vr">API </span><span class="vr">wants<span class="op">.</span>
</span><span class="vr">	final </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointSubset<span class="op">{</span></span><span class="vr"><span class="op">}</span>
</span><span class="kw">	for </span><span class="vr">key<span class="op">,</span> </span><span class="vr">ports </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">addrReadyMapKeyToPorts </span><span class="vr"><span class="op">{</span>
</span><span class="kw">		var </span><span class="vr">readyAddrs<span class="op">,</span> </span><span class="vr">notReadyAddrs </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress
</span><span class="kw">		for </span><span class="vr">addr<span class="op">,</span> </span><span class="vr">ready </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">keyToAddrReadyMap<span class="op">[</span></span><span class="vr">key<span class="op">]</span> </span><span class="vr"><span class="op">{</span>
</span><span class="kw">			if </span><span class="vr">ready </span><span class="vr"><span class="op">{</span>
</span><span class="vr">				readyAddrs </span><span class="vr"><span class="op">=</span> </span><span class="vr">append<span class="op">(</span></span><span class="vr">readyAddrs<span class="op">,</span> </span><span class="vr"><span class="op">*</span></span><span class="vr">addr<span class="op">)</span>
</span><span class="vr">			<span class="op">}</span> </span><span class="kw">else </span><span class="vr"><span class="op">{</span>
</span><span class="vr">				notReadyAddrs </span><span class="vr"><span class="op">=</span> </span><span class="vr">append<span class="op">(</span></span><span class="vr">notReadyAddrs<span class="op">,</span> </span><span class="vr"><span class="op">*</span></span><span class="vr">addr<span class="op">)</span>
</span><span class="vr">			<span class="op">}</span>
</span><span class="vr">		<span class="op">}</span>
</span><span class="vr">		final </span><span class="vr"><span class="op">=</span> </span><span class="vr">append<span class="op">(</span></span><span class="vr">final<span class="op">,</span> </span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointSubset<span class="op">{</span></span><span class="vr">Addresses<span class="op">:</span> </span><span class="vr">readyAddrs<span class="op">,</span> </span><span class="vr">NotReadyAddresses<span class="op">:</span> </span><span class="vr">notReadyAddrs<span class="op">,</span> </span><span class="vr">Ports<span class="op">:</span> </span><span class="vr">ports<span class="op">}</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	<span class="op">}</span>
</span><span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Finally<span class="op">,</span> </span><span class="vr">sort </span><span class="vr">it<span class="op">.</span>
</span><span class="kw">	return </span><span class="vr">SortSubsets<span class="op">(</span></span><span class="vr">final<span class="op">)</span>
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">The </span><span class="vr">sets </span><span class="vr">of </span><span class="vr">hosts </span><span class="vr">must </span><span class="vr">be </span><span class="vr">de<span class="op">-</span></span><span class="vr">duped<span class="op">,</span> </span><span class="vr">using </span><span class="vr">IP<span class="op">+</span></span><span class="vr">UID </span><span class="vr">as </span><span class="vr">the </span><span class="vr">key<span class="op">.</span>
</span><span class="kw">type </span><span class="vr">addressKey </span><span class="kw">struct </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	ip </span><span> </span><span class="tp">string
</span><span class="vr">	uid </span><span class="vr">types<span class="op">.</span></span><span class="vr">UID
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">mapAddressesByPort </span><span class="vr">adds </span><span class="vr">all </span><span class="vr">ready </span><span class="vr">and </span><span class="vr">not<span class="op">-</span></span><span class="vr">ready </span><span class="vr">addresses </span><span class="vr">into </span><span class="vr">a </span><span class="kw">map </span><span class="vr">by </span><span class="vr">a </span><span class="vr">single </span><span class="vr">port<span class="op">.</span>
</span><span class="kw">func </span><span class="vr">mapAddressesByPort<span class="op">(</span></span><span class="vr">subset </span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointSubset<span class="op">,</span> </span><span class="vr">port </span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointPort<span class="op">,</span> </span><span class="vr">allAddrs </span><span class="kw">map<span class="op">[</span></span><span class="vr">addressKey<span class="op">]</span></span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress<span class="op">,</span> </span><span class="vr">portToAddrReadyMap </span><span class="kw">map<span class="op">[</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointPort<span class="op">]</span></span><span class="vr">addressSet<span class="op">)</span> </span><span class="vr"><span class="op">{</span>
</span><span class="kw">	for </span><span class="vr">k </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">subset<span class="op">.</span></span><span class="vr">Addresses </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		mapAddressByPort<span class="op">(</span></span><span class="vr"><span class="op">&</span></span><span class="vr">subset<span class="op">.</span></span><span class="vr">Addresses<span class="op">[</span></span><span class="vr">k<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">port<span class="op">,</span> </span><span class="vr">true<span class="op">,</span> </span><span class="vr">allAddrs<span class="op">,</span> </span><span class="vr">portToAddrReadyMap<span class="op">)</span>
</span><span class="vr">	<span class="op">}</span>
</span><span class="kw">	for </span><span class="vr">k </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">subset<span class="op">.</span></span><span class="vr">NotReadyAddresses </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		mapAddressByPort<span class="op">(</span></span><span class="vr"><span class="op">&</span></span><span class="vr">subset<span class="op">.</span></span><span class="vr">NotReadyAddresses<span class="op">[</span></span><span class="vr">k<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">port<span class="op">,</span> </span><span class="vr">false<span class="op">,</span> </span><span class="vr">allAddrs<span class="op">,</span> </span><span class="vr">portToAddrReadyMap<span class="op">)</span>
</span><span class="vr">	<span class="op">}</span>
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">mapAddressByPort </span><span class="vr">adds </span><span class="vr">one </span><span class="vr">address </span><span class="vr">into </span><span class="vr">a </span><span class="kw">map </span><span class="vr">by </span><span class="vr">port<span class="op">,</span> </span><span class="vr">registering </span><span class="vr">the </span><span class="vr">address </span><span class="vr">with </span><span class="vr">a </span><span class="vr">unique </span><span class="vr">pointer<span class="op">,</span> </span><span class="vr">and </span><span class="vr">preserving
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">any </span><span class="vr">existing </span><span class="vr">ready </span><span class="vr">state<span class="op">.</span>
</span><span class="kw">func </span><span class="vr">mapAddressByPort<span class="op">(</span></span><span class="vr">addr </span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress<span class="op">,</span> </span><span class="vr">port </span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointPort<span class="op">,</span> </span><span class="vr">ready </span><span class="tp">bool<span class="op">,</span> </span><span class="vr">allAddrs </span><span class="kw">map<span class="op">[</span></span><span class="vr">addressKey<span class="op">]</span></span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress<span class="op">,</span> </span><span class="vr">portToAddrReadyMap </span><span class="kw">map<span class="op">[</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointPort<span class="op">]</span></span><span class="vr">addressSet<span class="op">)</span> </span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">use </span><span class="vr">addressKey </span><span class="vr">to </span><span class="vr">distinguish </span><span class="vr">between </span><span class="vr">two </span><span class="vr">endpoints </span><span class="vr">that </span><span class="vr">are </span><span class="vr">identical </span><span class="vr">addresses
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">but </span><span class="vr">may </span><span class="vr">have </span><span class="vr">come </span><span class="vr">from </span><span class="vr">different </span><span class="vr">hosts<span class="op">,</span> </span><span class="kw">for </span><span class="vr">attribution<span class="op">.</span> </span><span class="vr">For </span><span class="vr">instance<span class="op">,</span> </span><span class="vr">Mesos
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">assigns </span><span class="vr">pods </span><span class="vr">the </span><span class="vr">node </span><span class="vr">IP<span class="op">,</span> </span><span class="vr">but </span><span class="vr">the </span><span class="vr">pods </span><span class="vr">are </span><span class="vr">distinct<span class="op">.</span>
</span><span class="vr">	key </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">addressKey<span class="op">{</span></span><span class="vr">ip<span class="op">:</span> </span><span class="vr">addr<span class="op">.</span></span><span class="vr">IP<span class="op">}</span>
</span><span class="kw">	if </span><span class="vr">addr<span class="op">.</span></span><span class="vr">TargetRef </span><span class="vr"><span class="op">!</span></span><span class="vr"><span class="op">=</span> </span><span class="tp">nil </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		key<span class="op">.</span></span><span class="vr">uid </span><span class="vr"><span class="op">=</span> </span><span class="vr">addr<span class="op">.</span></span><span class="vr">TargetRef<span class="op">.</span></span><span class="vr">UID
</span><span class="vr">	<span class="op">}</span>
</span><span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Accumulate </span><span class="vr">the </span><span class="vr">address<span class="op">.</span> </span><span class="vr">The </span><span class="vr">full </span><span class="vr">EndpointAddress </span><span class="vr">structure </span><span class="vr">is </span><span class="vr">preserved </span><span class="kw">for </span><span class="vr">use </span><span class="vr">when
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">we </span><span class="vr">rebuild </span><span class="vr">the </span><span class="vr">subsets </span><span class="vr">so </span><span class="vr">that </span><span class="vr">the </span><span class="vr">final </span><span class="vr">TargetRef </span><span class="vr">has </span><span class="vr">all </span><span class="vr">of </span><span class="vr">the </span><span class="vr">necessary </span><span class="vr">data<span class="op">.</span>
</span><span class="vr">	existingAddress </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">allAddrs<span class="op">[</span></span><span class="vr">key<span class="op">]</span>
</span><span class="kw">	if </span><span class="vr">existingAddress </span><span class="vr"><span class="op">=</span></span><span class="vr"><span class="op">=</span> </span><span class="tp">nil </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Make </span><span class="vr">a </span><span class="vr">copy </span><span class="vr">so </span><span class="vr">we </span><span class="vr">don't </span><span class="vr">write </span><span class="vr">to </span><span class="vr">the
</span><span class="vr">		<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">input </span><span class="vr">args </span><span class="vr">of </span><span class="vr">this </span><span class="vr">function<span class="op">.</span>
</span><span class="vr">		existingAddress </span><span class="vr"><span class="op">=</span> </span><span class="vr"><span class="op">&</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress<span class="op">{</span></span><span class="vr"><span class="op">}</span>
</span><span class="vr">		<span class="op">*</span></span><span class="vr">existingAddress </span><span class="vr"><span class="op">=</span> </span><span class="vr"><span class="op">*</span></span><span class="vr">addr
</span><span class="vr">		allAddrs<span class="op">[</span></span><span class="vr">key<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">existingAddress
</span><span class="vr">	<span class="op">}</span>
</span><span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Remember </span><span class="vr">that </span><span class="vr">this </span><span class="vr">port </span><span class="vr">maps </span><span class="vr">to </span><span class="vr">this </span><span class="vr">address<span class="op">.</span>
</span><span class="kw">	if </span><span class="vr">_<span class="op">,</span> </span><span class="vr">found </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">portToAddrReadyMap<span class="op">[</span></span><span class="vr">port<span class="op">]</span></span><span class="vr"><span class="op">;</span> </span><span class="vr"><span class="op">!</span></span><span class="vr">found </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		portToAddrReadyMap<span class="op">[</span></span><span class="vr">port<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">addressSet<span class="op">{</span></span><span class="vr"><span class="op">}</span>
</span><span class="vr">	<span class="op">}</span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="kw">if </span><span class="vr">we </span><span class="vr">have </span><span class="vr">not </span><span class="vr">yet </span><span class="vr">recorded </span><span class="vr">this </span><span class="vr">port </span><span class="kw">for </span><span class="vr">this </span><span class="vr">address<span class="op">,</span> </span><span class="vr">or </span><span class="kw">if </span><span class="vr">the </span><span class="vr">previous
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">state </span><span class="vr">was </span><span class="vr">ready<span class="op">,</span> </span><span class="vr">write </span><span class="vr">the </span><span class="vr">current </span><span class="vr">ready </span><span class="vr">state<span class="op">.</span> </span><span class="vr">not </span><span class="vr">ready </span><span class="vr">always </span><span class="vr">trumps
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">ready<span class="op">.</span>
</span><span class="kw">	if </span><span class="vr">wasReady<span class="op">,</span> </span><span class="vr">found </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">portToAddrReadyMap<span class="op">[</span></span><span class="vr">port<span class="op">]</span></span><span class="vr"><span class="op">[</span></span><span class="vr">existingAddress<span class="op">]</span></span><span class="vr"><span class="op">;</span> </span><span class="vr"><span class="op">!</span></span><span class="vr">found </span><span class="vr"><span class="op">|</span></span><span class="vr"><span class="op">|</span> </span><span class="vr">wasReady </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		portToAddrReadyMap<span class="op">[</span></span><span class="vr">port<span class="op">]</span></span><span class="vr"><span class="op">[</span></span><span class="vr">existingAddress<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">ready
</span><span class="vr">	<span class="op">}</span>
</span><span class="kw">	return </span><span class="vr">existingAddress
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="kw">type </span><span class="vr">addressSet </span><span class="kw">map<span class="op">[</span></span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress<span class="op">]</span></span><span class="tp">bool
</span><span>
</span><span class="kw">type </span><span class="vr">addrReady </span><span class="kw">struct </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	addr </span><span> </span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress
</span><span class="vr">	ready </span><span class="tp">bool
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="kw">func </span><span class="vr">hashAddresses<span class="op">(</span></span><span class="vr">addrs </span><span class="vr">addressSet<span class="op">)</span> </span><span class="tp">string </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">Flatten </span><span class="vr">the </span><span class="vr">list </span><span class="vr">of </span><span class="vr">addresses </span><span class="vr">into </span><span class="vr">a </span><span class="tp">string </span><span class="vr">so </span><span class="vr">it </span><span class="vr">can </span><span class="vr">be </span><span class="vr">used </span><span class="vr">as </span><span class="vr">a
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="kw">map </span><span class="vr">key<span class="op">.</span> </span><span> </span><span class="vr">Unfortunately<span class="op">,</span> </span><span class="vr">DeepHashObject </span><span class="vr">is </span><span class="vr">implemented </span><span class="vr">in </span><span class="vr">terms </span><span class="vr">of
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">spew<span class="op">,</span> </span><span class="vr">and </span><span class="vr">spew </span><span class="vr">does </span><span class="vr">not </span><span class="vr">handle </span><span class="vr">non<span class="op">-</span></span><span class="vr">primitive </span><span class="kw">map </span><span class="vr">keys </span><span class="vr">well<span class="op">.</span> </span><span> </span><span class="vr">So
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">first </span><span class="vr">we </span><span class="vr">collapse </span><span class="vr">it </span><span class="vr">into </span><span class="vr">a </span><span class="vr">slice<span class="op">,</span> </span><span class="vr">sort </span><span class="vr">the </span><span class="vr">slice<span class="op">,</span> </span><span class="vr">then </span><span class="vr">hash </span><span class="vr">that<span class="op">.</span>
</span><span class="vr">	slice </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">make<span class="op">(</span></span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">addrReady<span class="op">,</span> </span><span class="vr">0<span class="op">,</span> </span><span class="vr">len<span class="op">(</span></span><span class="vr">addrs<span class="op">)</span></span><span class="vr"><span class="op">)</span>
</span><span class="kw">	for </span><span class="vr">k<span class="op">,</span> </span><span class="vr">ready </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">addrs </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		slice </span><span class="vr"><span class="op">=</span> </span><span class="vr">append<span class="op">(</span></span><span class="vr">slice<span class="op">,</span> </span><span class="vr">addrReady<span class="op">{</span></span><span class="vr">k<span class="op">,</span> </span><span class="vr">ready<span class="op">}</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	<span class="op">}</span>
</span><span class="vr">	sort<span class="op">.</span></span><span class="vr">Sort<span class="op">(</span></span><span class="vr">addrsReady<span class="op">(</span></span><span class="vr">slice<span class="op">)</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	hasher </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">md5<span class="op">.</span></span><span class="vr">New<span class="op">(</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	hashutil<span class="op">.</span></span><span class="vr">DeepHashObject<span class="op">(</span></span><span class="vr">hasher<span class="op">,</span> </span><span class="vr">slice<span class="op">)</span>
</span><span class="kw">	return </span><span class="vr">hex<span class="op">.</span></span><span class="vr">EncodeToString<span class="op">(</span></span><span class="vr">hasher<span class="op">.</span></span><span class="vr">Sum<span class="op">(</span></span><span class="tp">nil<span class="op">)</span></span><span class="vr"><span class="op">[</span></span><span class="vr">0<span class="op">:</span></span><span class="vr"><span class="op">]</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="kw">func </span><span class="vr">lessAddrReady<span class="op">(</span></span><span class="vr">a<span class="op">,</span> </span><span class="vr">b </span><span class="vr">addrReady<span class="op">)</span> </span><span class="tp">bool </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	<span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">ready </span><span class="vr">is </span><span class="vr">not </span><span class="vr">significant </span><span class="vr">to </span><span class="vr">hashing </span><span class="vr">since </span><span class="vr">we </span><span class="vr">can't </span><span class="vr">have </span><span class="vr">duplicate </span><span class="vr">addresses
</span><span class="kw">	return </span><span class="vr">LessEndpointAddress<span class="op">(</span></span><span class="vr">a<span class="op">.</span></span><span class="vr">addr<span class="op">,</span> </span><span class="vr">b<span class="op">.</span></span><span class="vr">addr<span class="op">)</span>
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="kw">type </span><span class="vr">addrsReady </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">addrReady
</span><span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">addrsReady<span class="op">)</span> </span><span class="vr">Len<span class="op">(</span></span><span class="vr"><span class="op">)</span> </span><span class="tp">int </span><span> </span><span> </span><span> </span><span> </span><span> </span><span class="vr"><span class="op">{</span> </span><span class="kw">return </span><span class="vr">len<span class="op">(</span></span><span class="vr">sl<span class="op">)</span> </span><span class="vr"><span class="op">}</span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">addrsReady<span class="op">)</span> </span><span class="vr">Swap<span class="op">(</span></span><span class="vr">i<span class="op">,</span> </span><span class="vr">j </span><span class="tp">int<span class="op">)</span> </span><span class="vr"><span class="op">{</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span> </span><span class="vr"><span class="op">}</span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">addrsReady<span class="op">)</span> </span><span class="vr">Less<span class="op">(</span></span><span class="vr">i<span class="op">,</span> </span><span class="vr">j </span><span class="tp">int<span class="op">)</span> </span><span class="tp">bool </span><span class="vr"><span class="op">{</span>
</span><span class="kw">	return </span><span class="vr">lessAddrReady<span class="op">(</span></span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">LessEndpointAddress </span><span class="vr">compares </span><span class="vr">IP </span><span class="vr">addresses </span><span class="vr">lexicographically </span><span class="vr">and </span><span class="vr">returns </span><span class="vr">true </span><span class="kw">if </span><span class="vr">first </span><span class="vr">argument </span><span class="vr">is </span><span class="vr">lesser </span><span class="vr">than </span><span class="vr">second
</span><span class="kw">func </span><span class="vr">LessEndpointAddress<span class="op">(</span></span><span class="vr">a<span class="op">,</span> </span><span class="vr">b </span><span class="vr"><span class="op">*</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress<span class="op">)</span> </span><span class="tp">bool </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	ipComparison </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">bytes<span class="op">.</span></span><span class="vr">Compare<span class="op">(</span></span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="tp">byte<span class="op">(</span></span><span class="vr">a<span class="op">.</span></span><span class="vr">IP<span class="op">)</span></span><span class="vr"><span class="op">,</span> </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="tp">byte<span class="op">(</span></span><span class="vr">b<span class="op">.</span></span><span class="vr">IP<span class="op">)</span></span><span class="vr"><span class="op">)</span>
</span><span class="kw">	if </span><span class="vr">ipComparison </span><span class="vr"><span class="op">!</span></span><span class="vr"><span class="op">=</span> </span><span class="nm">0 </span><span class="vr"><span class="op">{</span>
</span><span class="kw">		return </span><span class="vr">ipComparison </span><span class="vr"><span class="op"><</span> </span><span class="nm">0
</span><span class="vr">	<span class="op">}</span>
</span><span class="kw">	if </span><span class="vr">b<span class="op">.</span></span><span class="vr">TargetRef </span><span class="vr"><span class="op">=</span></span><span class="vr"><span class="op">=</span> </span><span class="tp">nil </span><span class="vr"><span class="op">{</span>
</span><span class="kw">		return </span><span class="vr">false
</span><span class="vr">	<span class="op">}</span>
</span><span class="kw">	if </span><span class="vr">a<span class="op">.</span></span><span class="vr">TargetRef </span><span class="vr"><span class="op">=</span></span><span class="vr"><span class="op">=</span> </span><span class="tp">nil </span><span class="vr"><span class="op">{</span>
</span><span class="kw">		return </span><span class="vr">true
</span><span class="vr">	<span class="op">}</span>
</span><span class="kw">	return </span><span class="vr">a<span class="op">.</span></span><span class="vr">TargetRef<span class="op">.</span></span><span class="vr">UID </span><span class="vr"><span class="op"><</span> </span><span class="vr">b<span class="op">.</span></span><span class="vr">TargetRef<span class="op">.</span></span><span class="vr">UID
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">SortSubsets </span><span class="vr">sorts </span><span class="vr">an </span><span class="vr">array </span><span class="vr">of </span><span class="vr">EndpointSubset </span><span class="vr">objects </span><span class="vr">in </span><span class="vr">place<span class="op">.</span> </span><span> </span><span class="vr">For </span><span class="vr">ease </span><span class="vr">of
</span><span class="vr"><span class="op">/</span></span><span class="vr"><span class="op">/</span> </span><span class="vr">use </span><span class="vr">it </span><span class="vr">returns </span><span class="vr">the </span><span class="vr">input </span><span class="vr">slice<span class="op">.</span>
</span><span class="kw">func </span><span class="vr">SortSubsets<span class="op">(</span></span><span class="vr">subsets </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointSubset<span class="op">)</span> </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointSubset </span><span class="vr"><span class="op">{</span>
</span><span class="kw">	for </span><span class="vr">i </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="kw">range </span><span class="vr">subsets </span><span class="vr"><span class="op">{</span>
</span><span class="vr">		ss </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr"><span class="op">&</span></span><span class="vr">subsets<span class="op">[</span></span><span class="vr">i<span class="op">]</span>
</span><span class="vr">		sort<span class="op">.</span></span><span class="vr">Sort<span class="op">(</span></span><span class="vr">addrsByIPAndUID<span class="op">(</span></span><span class="vr">ss<span class="op">.</span></span><span class="vr">Addresses<span class="op">)</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">		sort<span class="op">.</span></span><span class="vr">Sort<span class="op">(</span></span><span class="vr">addrsByIPAndUID<span class="op">(</span></span><span class="vr">ss<span class="op">.</span></span><span class="vr">NotReadyAddresses<span class="op">)</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">		sort<span class="op">.</span></span><span class="vr">Sort<span class="op">(</span></span><span class="vr">portsByHash<span class="op">(</span></span><span class="vr">ss<span class="op">.</span></span><span class="vr">Ports<span class="op">)</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	<span class="op">}</span>
</span><span class="vr">	sort<span class="op">.</span></span><span class="vr">Sort<span class="op">(</span></span><span class="vr">subsetsByHash<span class="op">(</span></span><span class="vr">subsets<span class="op">)</span></span><span class="vr"><span class="op">)</span>
</span><span class="kw">	return </span><span class="vr">subsets
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="kw">func </span><span class="vr">hashObject<span class="op">(</span></span><span class="vr">hasher </span><span class="vr">hash<span class="op">.</span></span><span class="vr">Hash<span class="op">,</span> </span><span class="vr">obj </span><span class="kw">interface<span class="op">{</span></span><span class="vr"><span class="op">}</span></span><span class="vr"><span class="op">)</span> </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="tp">byte </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	hashutil<span class="op">.</span></span><span class="vr">DeepHashObject<span class="op">(</span></span><span class="vr">hasher<span class="op">,</span> </span><span class="vr">obj<span class="op">)</span>
</span><span class="kw">	return </span><span class="vr">hasher<span class="op">.</span></span><span class="vr">Sum<span class="op">(</span></span><span class="tp">nil<span class="op">)</span>
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="kw">type </span><span class="vr">subsetsByHash </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointSubset
</span><span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">subsetsByHash<span class="op">)</span> </span><span class="vr">Len<span class="op">(</span></span><span class="vr"><span class="op">)</span> </span><span class="tp">int </span><span> </span><span> </span><span> </span><span> </span><span> </span><span class="vr"><span class="op">{</span> </span><span class="kw">return </span><span class="vr">len<span class="op">(</span></span><span class="vr">sl<span class="op">)</span> </span><span class="vr"><span class="op">}</span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">subsetsByHash<span class="op">)</span> </span><span class="vr">Swap<span class="op">(</span></span><span class="vr">i<span class="op">,</span> </span><span class="vr">j </span><span class="tp">int<span class="op">)</span> </span><span class="vr"><span class="op">{</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span> </span><span class="vr"><span class="op">}</span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">subsetsByHash<span class="op">)</span> </span><span class="vr">Less<span class="op">(</span></span><span class="vr">i<span class="op">,</span> </span><span class="vr">j </span><span class="tp">int<span class="op">)</span> </span><span class="tp">bool </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	hasher </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">md5<span class="op">.</span></span><span class="vr">New<span class="op">(</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	h1 </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">hashObject<span class="op">(</span></span><span class="vr">hasher<span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	h2 </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">hashObject<span class="op">(</span></span><span class="vr">hasher<span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span></span><span class="vr"><span class="op">)</span>
</span><span class="kw">	return </span><span class="vr">bytes<span class="op">.</span></span><span class="vr">Compare<span class="op">(</span></span><span class="vr">h1<span class="op">,</span> </span><span class="vr">h2<span class="op">)</span> </span><span class="vr"><span class="op"><</span> </span><span class="nm">0
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="kw">type </span><span class="vr">addrsByIPAndUID </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointAddress
</span><span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">addrsByIPAndUID<span class="op">)</span> </span><span class="vr">Len<span class="op">(</span></span><span class="vr"><span class="op">)</span> </span><span class="tp">int </span><span> </span><span> </span><span> </span><span> </span><span> </span><span class="vr"><span class="op">{</span> </span><span class="kw">return </span><span class="vr">len<span class="op">(</span></span><span class="vr">sl<span class="op">)</span> </span><span class="vr"><span class="op">}</span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">addrsByIPAndUID<span class="op">)</span> </span><span class="vr">Swap<span class="op">(</span></span><span class="vr">i<span class="op">,</span> </span><span class="vr">j </span><span class="tp">int<span class="op">)</span> </span><span class="vr"><span class="op">{</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span> </span><span class="vr"><span class="op">}</span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">addrsByIPAndUID<span class="op">)</span> </span><span class="vr">Less<span class="op">(</span></span><span class="vr">i<span class="op">,</span> </span><span class="vr">j </span><span class="tp">int<span class="op">)</span> </span><span class="tp">bool </span><span class="vr"><span class="op">{</span>
</span><span class="kw">	return </span><span class="vr">LessEndpointAddress<span class="op">(</span></span><span class="vr"><span class="op">&</span></span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr"><span class="op">&</span></span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr"><span class="op">}</span>
</span><span>
</span><span class="kw">type </span><span class="vr">portsByHash </span><span class="vr"><span class="op">[</span></span><span class="vr"><span class="op">]</span></span><span class="vr">v1<span class="op">.</span></span><span class="vr">EndpointPort
</span><span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">portsByHash<span class="op">)</span> </span><span class="vr">Len<span class="op">(</span></span><span class="vr"><span class="op">)</span> </span><span class="tp">int </span><span> </span><span> </span><span> </span><span> </span><span> </span><span class="vr"><span class="op">{</span> </span><span class="kw">return </span><span class="vr">len<span class="op">(</span></span><span class="vr">sl<span class="op">)</span> </span><span class="vr"><span class="op">}</span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">portsByHash<span class="op">)</span> </span><span class="vr">Swap<span class="op">(</span></span><span class="vr">i<span class="op">,</span> </span><span class="vr">j </span><span class="tp">int<span class="op">)</span> </span><span class="vr"><span class="op">{</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span> </span><span class="vr"><span class="op">=</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span></span><span class="vr"><span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span> </span><span class="vr"><span class="op">}</span>
</span><span class="kw">func </span><span class="vr"><span class="op">(</span></span><span class="vr">sl </span><span class="vr">portsByHash<span class="op">)</span> </span><span class="vr">Less<span class="op">(</span></span><span class="vr">i<span class="op">,</span> </span><span class="vr">j </span><span class="tp">int<span class="op">)</span> </span><span class="tp">bool </span><span class="vr"><span class="op">{</span>
</span><span class="vr">	hasher </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">md5<span class="op">.</span></span><span class="vr">New<span class="op">(</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	h1 </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">hashObject<span class="op">(</span></span><span class="vr">hasher<span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">i<span class="op">]</span></span><span class="vr"><span class="op">)</span>
</span><span class="vr">	h2 </span><span class="vr"><span class="op">:</span></span><span class="vr"><span class="op">=</span> </span><span class="vr">hashObject<span class="op">(</span></span><span class="vr">hasher<span class="op">,</span> </span><span class="vr">sl<span class="op">[</span></span><span class="vr">j<span class="op">]</span></span><span class="vr"><span class="op">)</span>
</span><span class="kw">	return </span><span class="vr">bytes<span class="op">.</span></span><span class="vr">Compare<span class="op">(</span></span><span class="vr">h1<span class="op">,</span> </span><span class="vr">h2<span class="op">)</span> </span><span class="vr"><span class="op"><</span> </span><span class="nm">0
</span><span class="vr"><span class="op">}</span>
</span>    </pre>
</body>
</html>